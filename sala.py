"""Por hacer:    Decidir como hacer los movimientos y como se elimina el sprite de este (mañana lo hablamos en clase para ver como compatibilizarlo con pygame)    Funcion get_info de game (si es que la necesitamos)    Acabar el on_message con todos los posibles eventos""""""Observaciones: La clase player creo que se puede eliminar"""from multiprocessing import Process, Manager, Value, Lockimport tracebackfrom paho.mqtt.client import Clientimport numpy as npimport timeimport pickle, sysPOSICIONES = [(400,300), (1500,300), (950,750)]costesNivel = {2: 5, 3: 10, 4: 20, 5: 50}maxCapNivel = {1: 20, 2: 50, 3: 100, 4:150, 5: 200}prodNivel = {1:1, 2:1.5, 3:2, 4:2.4, 5:2.75}modosAtaque = {1: 0, 2: 50, 3:100}velocidadMovimientos = 5capInicialJug = 20capInicialLibre = 5#DEFINIMOS LAS CLASES DE LA SALAclass Ciudad():    def __init__(self, pos, cid, prop=None):        self.posicion = pos        self.id = cid        self.propietario = prop        self.nivel = 1        self.poblacion = capInicialJug if self.propietario == None else capInicialLibre        self.max_capacidad = maxCapNivel[self.nivel]        self.produccion = prodNivel[self.nivel]    def subirNivel(self):        if self.nivel < 5 and self.poblacion > costesNivel[self.nivel+1] :            self.nivel += 1            self.poblacion -= costesNivel[self.nivel]            self.produccion = prodNivel[self.nivel]            self.max_capapacidad = maxCapNivel[self.nivel]        def update(self):        # La capacidad maxima se puede exceder si llegan refuerzos, pero a partir de ese punto, la ciudad no produce nuevos soldados        if self.propietario != None and self.poblacion < self.max_capacidad:            self.poblacion += self.produccion            if self.poblacion > self.max_capacidad: self.poblacion = self.max_capacidad    def __str__(self):        return f"Posicion: {self.posicion}, id: {self.id}, propietario: {self.propietario}, nivel: {self.nivel}, poblacion: {self.poblacion}"        class Player():    def __init__(self, pid, ciudades): #No haria falta pasar capital como argumento        self.pid = pid        self.ciudades = ciudades        #self.capital = capital        #def subirNivel(self):        #self.capital.subirNivel()        #def cambiarCapital(self, c2):        #if c2 in self.ciudades:            #self.capital = c2class Game():    def __init__(self, gameinfo):        self.jugadores = gameinfo['jugadores']        self.ciudades = gameinfo['ciudades']        self.movimientos = gameinfo['movimientos']        self.running = gameinfo['is_running']        self.lock = Lock()                          # Esta clase actúa como un monitor que asegura la concurrencia    def is_running(self):        return self.running        # Esto no iba con un static method?    def stop(self):        self.running =  False            # Game es el encargado de llevar las acciones que le indica el jugador mediante los process, asi que definimos estas operaciones    # Aqui solo se consideran tres acciones por parte del jugador:        # Atacar otra ciudad desde su capital        # Subir de nivel una ciudad    # Estas operaciones son las que hay que proteger con semaforos        def movimiento(self, c1, c2, mode):        with self.lock:            porcTropas = modosAtaque[mode]/100            n_tropas = (c1.poblacion * porcTropas) if porcTropas != 0 else 5            c1.poblacion -= n_tropas            self.movimientos.append( (c1,c2) )            p = Process(target = movimiento,  args = (c1,c2,n_tropas))            p.start()                   def subirNivel(self, ciudad):        with self.lock:            ciudad.subirNivel()    def update(self):        with self.lock:            for ciudad in self.ciudades:                ciudad.update()            #for mov in self.movimientos:                #mov.update()        def get_info(self):        gameinfo = gameinfo = {'ciudades': self.ciudades, 'jugadores': self.jugadores, 'movimientos': self.movimientos[:], 'is_running': True}        self.movimientos = []        return gameinfo#Funcion que luego usaran los procesos de llegadadef movimiento(ciudad1, ciudad2, n_tropas):    distancia = np.linalg.norm( np.array(ciudad2.c.pos) - np.array(ciudad1.c.pos) )    tiempo = distancia/velocidadMovimientos    time.sleep(tiempo)    # Todo esto hay que hacerlo con Managers, Values o con mensajes, pero aqui la poblacion se edita en una variable local del proceso y no cambia nada en el game    ciudad2.poblacion -= n_tropas     if ciudad2.poblacion <= 0:          #Si conquista la ciudad se le quita al otro y se la queda el atacante        enemigo = ciudad2.propietario        jugadores[enemigo-1].ciudades.pop(ciudad2)        jugadores[pid-1].ciudades.append(ciudad2)        ciudad2.propietario = pid        ciudad2.poblacion *= -1        #FUNCIONES MQTTdef on_connect(client, userdata, flags, rc):    print(f"Se ha conseguido conectar a {broker}")    print("Esperando a que se conecten los jugadores ...")# Obs: on_message NO publica mensajes (excepto en nuevas conexiones), eso lo hace el bucle de la sala para que tenga en cuenta todos los updates. Ademas, tal y como estaba se actualizaba game pero no gameinfodef on_message(client, userdata, msg):    info = pickle.loads(msg.payload)    print("\n\n", info, "\n\n")    try:            if info == "Nueva conexion":            n = userdata["num_jug"]            ciudad_n = userdata["game"].ciudades[n]            userdata["num_jug"] += 1            ciudad_n.propietario = n                      # Comprobar si esto cambia la entrada de game del diccionario, si no, definir game.cambiarPropietario y asi se hace ademas con el lock por si acaso            userdata["game"].jugadores.append( Player(n, ciudad_n) )            client.publish(new_player, pickle.dumps((userdata["num_jug"], userdata["game"].get_info() )) )                    elif info == "quit":            userdata["game"].running = False                    elif info[1] == "ready" and not(userdata["start"]):            userdata["readys"].add(info[0])            userdata["start"] = (( userdata["num_jug"] == len(userdata["readys"]) ) and userdata["num_jug"] > 0 )                    elif info[1] == "subirNivel":            ciudad = userdata["game"].ciudades[info[2]-1]            # Esto depende de si usamos el id de las ciudades desde 0 o desde 1!!            if ciudad.propietario == info[0]:                userdata["game"].subirNivel(ciudad)                     elif info[1] == "movimiento":            ciudad1 = userdata["game"].ciudades[info[2]-1]           # Esto depende de si usamos el id de las ciudades desde 0 o desde 1!!            ciudad2 = userdata["game"].ciudades[info[3]-1]           # Esto depende de si usamos el id de las ciudades desde 0 o desde 1!!            mode = info[4]            if ciudad1.propietario == info[0]:                userdata["game"].movimiento(ciudad1, ciudad2, mode)        else: print("BBBBBBBBBB")                except:        print("Ha habido un error")        traceback.print_exc()    finally:        print(userdata)        pass    ###def main(broker):    try:        # Generamos el juego                POSICIONES = [(400,300), (150,300), (150,450)] #Posicion de cada una de las ciudades (suponiendo que hay 3 jugadores)        ciudades = [Ciudad(POSICIONES[i], i+1) for i in range(3)] #Lista con todas las ciudades del tablero        gameinfo = {'ciudades': ciudades, 'jugadores': [], 'movimientos': [], 'is_running': True} #Declaramos el gameInfo        game = Game(gameinfo) #Creamos el juego                #PARTE MQTT                userdata = {"game": game, "num_jug":0, "readys":set(), "start":False}        client = Client(userdata = userdata)        client.on_connect = on_connect        client.on_message = on_message        # client.on_publish = on_publish        client.connect(broker)        client.subscribe(sala)        client.loop_start()                while True:            game.update()               # Comprobar que esto tambien altera la entrada de userdata            gameinfo = game.get_info()            client.publish(players, pickle.dumps(gameinfo))            # Otra forma, game.update(), userdata[gameinfo] = game.get_info            # Aqui habria que hacer algo para que hiciese lo de los ticks quiza                  ###    except Exception:        traceback.print_exc()        if __name__=="__main__":    broker = "simba.fdi.ucm.es"    sala = "clients/sala"    players = "clients/players"    new_player = "clients/new_players"    if len(sys.argv)>1:        broker = sys.argv[1]    main(broker)    #### AQUI HE DEJADO TODO LO QUE CREO QUE NO HACE FALTA#####Creo que dijimos que no nos hacía falta pero por si acaso lo dejo aqui#DEFINIMOS LOS PROCESOS QUE SON LOS QUE REALMENTE ENVIAN Y RECIBEN LOS MENSAJES Y LE DICEN A GAME LO QUE TIENE QUE HACER#def player(pid, game):    #try:        #print(f'starting player {pid}')        #enviaInfo(pid, gameInfo) nada mas ser creado        #while game.is_running():            #command = ''            #while command != 'next':                #command = recibeConexion()                #distingue casos y le dice a game como gestionar los comandos recibidos                #pass            #enviaInfo(gameInfo)            #NOTA: He pensado que una vez envia un ataque este sea borrado y que sean los jugadores los que gestionen ese ataque,            #Realmente solo tendrian que controlar los graficos                #except:        #traceback.print_exc()    #finally:        #print(f'Game ended')"""Si lo hacemnos con mensajes podria se algo como asiAunque, al fin y al cabo, puede que lo mas facil sea que los procesos de los movimientos se ejecuten en cada sala y jugador por separado:        gameinfo["movimientos"] se resetea en cada bucle.    Cada vez que se crea un movimiento, la sala crea un proceso con temporizafor y cuando el tempo acaba, resta la poblacion y evalua llegada, y añade el mov a gameinfo    Cada vez que un player recibe mensaje, añade todos los movimientos de gameinfo["movimientos"] y el mismo se encarga de gestionar su posicion y cuando lo borra (con otro proceso auxiliar)""" # class Movimiento():#     def __init__(self, ciudad1, ciudad2):#         self.destino = ciudad2#         self.prop = ciudad1.prop#         self.pos = ciudad1.pos#         self.direccion = np.array(ciudad2.c.pos) - np.array(ciudad1.c.pos)#         self.distancia = np.linalg.norm(self.direccion)#         self.vel = 5*self.direccion/self.distancia#         self.n_tropas = 5#         self.t = self.distancia/5#         self.c1.poblacion -= self.n_tropas       #         self.is_alive = Value('b',True)#         p = Process(target = self.llegada)#         p.start()        #     def llegada(self):#         client = Client()#         client.connect('simba.fdi.ucm.es')#         canal = "clients/movimientos"#         time.sleep(self.t)#         if self.prop == self.c2.prop:    #             client.publish(f"Apoyo {self.c2.cid} {self.n_tropas}", canal)#             # self.c2.poblacion += self.n_tropas#         else:#             client.publish(f"Ataque {self.c2.cid} {self.n_tropas}", canal)#             # self.c2.poblacion -= self.n_tropas#             if self.c2.poblacion < 1:#                 client.publish(f"Conquista {self.c2.cid} {self.prop}", canal)#                 # self.c2.prop = self.c1.prop#                 # self.c2.poblacion *= -1#         client.disconnect()        # ESTRUCTURA DE gameInfo: {'ciudades'=[c1,...,cn],#                          'players'=[p1,...,pn],#                          'movimientos'=[m1,...,mn],#                          'is_running' = True}#def Movimiento():    #def __init__(self, pid, ciudad):        #self.pid = pid #Añadimos un identificador de ataque que coincida con el del atacante suponiendo que no ataca dos sitios a la vez        #self.atacante = self.jugadores[pid-1]        #self.atacado = self.ciudad