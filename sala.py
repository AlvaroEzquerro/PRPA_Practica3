"""Por hacer:    Decidir como hacer los movimientos y como se elimina el sprite de este (mañana lo hablamos en clase para ver como compatibilizarlo con pygame)    Funcion get_info de game (si es que la necesitamos)    Acabar el on_message con todos los posibles eventos""""""Observaciones: La clase player creo que se puede eliminar"""from multiprocessing import Process, Manager, Value, Lockimport tracebackfrom paho.mqtt.client import Clientimport numpy as npimport timeimport pickle, sysPOSICIONES = [(400,300), (150,300), (150,450)] #Posicion de cada una de las ciudades (suponiendo que hay 3 jugadores)costesNivel = {2: 10, 3: 20, 4: 50, 5: 100}maxCapNivel = {1: 20, 2: 50, 3: 100, 4:150, 5: 200}prodNivel = {1:1, 2:1.5, 3:2, 4:2.4, 5:2.75}modosAtaque = {1: 0, 2: 50, 3:100}velocidadMovimientos = 100capInicialJug = 5capInicialLibre = 20FPS = 30#DEFINIMOS LAS CLASES DE LA SALAclass Ciudad():    def __init__(self, pos, cid, prop=None):        self.posicion = pos        self.id = cid        self.propietario = prop        self.nivel = 1        self.poblacion = capInicialJug if self.propietario == None else capInicialLibre        self.max_capacidad = maxCapNivel[self.nivel]        self.produccion = prodNivel[self.nivel]/FPS    def subirNivel(self):        if self.nivel < 5 and self.poblacion >= costesNivel[self.nivel+1] : #Habria que mirar si quitar esta condicion porque si no cuando se conquista una ciudad es imposible subirla de nivel            self.nivel += 1            self.poblacion -= costesNivel[self.nivel]            self.produccion = prodNivel[self.nivel]/FPS            self.max_capacidad = maxCapNivel[self.nivel]        def update(self):        # La capacidad maxima se puede exceder si llegan refuerzos, pero a partir de ese punto, la ciudad no produce nuevos soldados        if self.propietario != None and self.poblacion < self.max_capacidad:            self.poblacion += self.produccion            if self.poblacion > self.max_capacidad: self.poblacion = self.max_capacidad    def __repr__(self):        return f"Posicion: {self.posicion}, id: {self.id}, propietario: {self.propietario}, nivel: {self.nivel}, poblacion: {self.poblacion}"        class Player():    def __init__(self, pid, ciudades): #No haria falta pasar capital como argumento        self.pid = pid        self.ciudades = ciudades        #self.capital = capital        #def subirNivel(self):        #self.capital.subirNivel()        #def cambiarCapital(self, c2):        #if c2 in self.ciudades:            #self.capital = c2    def __repr__(self):        return f"Numero de jugador: {self.pid}, ciudades: {self.ciudades}"class Game():    def __init__(self, gameinfo, cambios):        self.jugadores = gameinfo['jugadores']        self.ciudades = gameinfo['ciudades']        self.movimientos = gameinfo['movimientos']        self.running = gameinfo['is_running']        self.lock = Lock()                          # Esta clase actúa como un monitor que asegura la concurrencia        self.cambios = cambios            def is_running(self):        return self.running        def stop(self):        self.running =  False            # Game es el encargado de llevar las acciones que le indica el jugador mediante los process, asi que definimos estas operaciones    # Aqui solo se consideran tres acciones por parte del jugador:        # Atacar otra ciudad desde su capital        # Subir de nivel una ciudad    # Estas operaciones son las que hay que proteger con semaforos        def movimiento(self, c1, c2, mode):        with self.lock:            porcTropas = modosAtaque[mode]/100            if porcTropas != 0:                n_tropas = (c1.poblacion * porcTropas)            else:                if c1.poblacion <=5:                    n_tropas = c1.poblacion                else:                    n_tropas = 5            c1.poblacion -= n_tropas            self.movimientos.append((c1,c2))            p = Process(target = proc_movimientos,  args = (c1,c2,n_tropas, self.cambios, self.lock))            p.start()                   def subirNivel(self, ciudad):        with self.lock:            ciudad.subirNivel()    def cambiarPropietario(self, ciudad, nuevoPropietario):        with self.lock:            ciudad.propietario = nuevoPropietario    def update(self):        with self.lock:            for jug, cid, n in list(self.cambios):                c2 = self.ciudades[cid]                # Todo esto hay que hacerlo con Managers, Values o con mensajes, pero aqui la poblacion se edita en una variable local del proceso y no cambia nada en el game                if c2.propietario == jug:                    c2.poblacion += n                else:                    c2.poblacion -= n                     if c2.poblacion <= 0:          #Si conquista la ciudad se le quita al otro y se la queda el atacante                        if c2.propietario != None:                            enemigo = c2.propietario                            self.jugadores[enemigo].ciudades.remove(c2)                        (self.jugadores[jug].ciudades).append(c2)                        c2.propietario = jug                        c2.poblacion *= -1                self.cambios.pop()            for ciudad in self.ciudades:                ciudad.update()             for c in self.cambios:                print(c)        def get_info(self):        with self.lock:            gameinfo = {'ciudades': self.ciudades, 'jugadores': self.jugadores, 'movimientos': self.movimientos, 'is_running': self.running}            #self.movimientos = []        return gameinfo    def terminado(self):        with self.lock:            prop = self.ciudades[0].propietario            for ciudad in self.ciudades:                if ciudad.propietario != prop or ciudad.propietario == None:                    return False        return True#Funcion que luego usaran los procesos de llegadadef proc_movimientos(ciudad1, ciudad2, n_tropas, cambios, lock):    distancia = np.linalg.norm( np.array(ciudad2.posicion) - np.array(ciudad1.posicion) )    tiempo = distancia/velocidadMovimientos    time.sleep(tiempo)    print("abrete sesamo")    with lock:        print("lock por fin abre")        cambios.append((ciudad1.propietario,ciudad2.id, n_tropas))    print("Ataque completado", cambios)        #FUNCIONES MQTTdef on_connect(client, userdata, flags, rc):    print(f"Se ha conseguido conectar a {broker}")    print("Esperando a que se conecten los jugadores ...")# Obs: on_message NO publica mensajes (excepto en nuevas conexiones), eso lo hace el bucle de la sala para que tenga en cuenta todos los updates. Ademas, tal y como estaba se actualizaba game pero no gameinfodef on_message(client, userdata, msg):    info = pickle.loads(msg.payload)    print("\n\n", info, "\n\n")    try:            if info == "Nueva conexion":            n = userdata["num_jug"]            ciudad_n = userdata["game"].ciudades[n]            userdata["num_jug"] += 1            userdata["game"].cambiarPropietario(ciudad_n, n)            userdata["game"].jugadores.append(Player(n,[ciudad_n]))            client.publish(new_player, pickle.dumps( (n, userdata["game"].get_info() )) )                    elif info == "quit":            userdata["game"].running = False                    elif info[1] == "ready" and not(userdata["start"]):            userdata["readys"].add(info[0])            userdata["start"] = (( userdata["num_jug"] == len(userdata["readys"]) ) and userdata["num_jug"] > 0 )                    elif info[1] == "subirNivel" and userdata["start"]:            print("dentro")            ciudad = userdata["game"].ciudades[info[2]]            # Esto depende de si usamos el id de las ciudades desde 0 o desde 1!!            print(ciudad)            if ciudad.propietario == info[0]:                print("dentrox2")                userdata["game"].subirNivel(ciudad)                print(ciudad)                    elif info[1] == "movimiento" and userdata["start"]:            ciudad1 = userdata["game"].ciudades[info[2]]           # Esto depende de si usamos el id de las ciudades desde 0 o desde 1!!            ciudad2 = userdata["game"].ciudades[info[3]]           # Esto depende de si usamos el id de las ciudades desde 0 o desde 1!!            mode = info[4]            if ciudad1.propietario == info[0]:                userdata["game"].movimiento(ciudad1, ciudad2, mode)        else: print("BBBBBBBBBB")                except:        print("Ha habido un error")        traceback.print_exc()    finally:        print(userdata)        pass    ###def main(broker):    try:        # Generamos el juego        m = Manager()        cambios = m.list()        ciudades = [Ciudad(POSICIONES[i], i) for i in range(3)] #Lista con todas las ciudades del tablero        gameinfo = {'ciudades': ciudades, 'jugadores': [], 'movimientos': [], 'is_running': True} #Declaramos el gameInfo        game = Game(gameinfo, cambios) #Creamos el juego                #PARTE MQTT                userdata = {"game": game, "num_jug":0, "readys":set(), "start":False}        client = Client(userdata = userdata)        client.on_connect = on_connect        client.on_message = on_message        # client.on_publish = on_publish        client.connect(broker)        client.subscribe(sala)        client.loop_start()                while game.running and not game.terminado():            tiempo_inicio = time.time()            if userdata["start"]:                game.update()               # Comprobar que esto tambien altera la entrada de userdata                gameinfo = game.get_info()                client.publish(players, pickle.dumps(gameinfo))                game.movimientos =  []            tiempo_bucle = time.time()-tiempo_inicio            time.sleep( max(0, 1/FPS - tiempo_bucle))            # Otra forma, game.update(), userdata[gameinfo] = game.get_info            # Aqui habria que hacer algo para que hiciese lo de los ticks quiza                  ###           except:        print("Ha habido un error")        traceback.print_exc()    finally:        time.sleep(1000)if __name__=="__main__":    broker = "simba.fdi.ucm.es"    sala = "clients/conquista/sala"    players = "clients/conquista/players"    new_player = "clients/conquista/new_players"    if len(sys.argv)>1:        broker = sys.argv[1]    main(broker)